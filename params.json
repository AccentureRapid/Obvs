{"name":"Obvs","tagline":"An observable ÂµServiceBus .NET library that wraps the complexities of your particular message transport in simple Rx based interfaces. Supported transports include: ActiveMQ, RabbitMQ, NetMQ, EventStore, and Kafka.","body":"## Why?\r\n\r\nWriting code to connect two processes can involve a lot of boilerplate. Every time you add a new service or message type, you find yourself repeating the same steps. Obvs takes care of this for you, and allows you to start connecting your services with very little code required, so you get more done.\r\n\r\n## Features\r\n\r\n* Leverage the power of messaging and RX to quickly construct a system of decoupled microservices\r\n* Add new services and message contracts with an absolute minimum amount of required code\r\n* Simple RX based interfaces for doing pub/sub\r\n* Convention based messaging over topics/queues per service\r\n* Multiplexing of multiple message types over single topics/queues\r\n* Dynamic creation of deserializers per type\r\n* Asynchronous error handling on a separate channel\r\n* Easy to extend and customise, allowing integration with external systems\r\n* Fluent code based configuration\r\n* Supports ActiveMQ, RabbitMQ, NetMQ, Kafka, Azure ServiceBus, and EventStore transports\r\n* Provides serialization for XML, JSON.Net, NetJson, ProtoBuf, and MsgPack\r\n* Provides logging extensions, and support for NLog and log4net\r\n* Provides monitoring extensions, and support for Windows Performance Counters, and ElasticSearch\r\n* Can be configured with a local memory bus for in-process service communication\r\n* Being a library and not a framework allows you to compose your application as you see fit\r\n\r\n## Getting Started\r\n\r\nAll packages can be downloaded from [NuGet.org](https://www.nuget.org/packages?q=obvs)\r\n\r\nChoose a message transport\r\n\r\n\tinstall-package Obvs.ActiveMQ\r\n\r\nChoose a serialization format\r\n\r\n\tinstall-package Obvs.Serialization.Json\r\n\r\n## Example\r\n\r\nDefine a root message type to identify messages as belonging to your service:\r\n\r\n\tpublic interface ITestServiceMessage : IMessage { }\r\n\r\nCreate command/event/request/response message types:\r\n\r\n\tpublic class TestCommand : ITestServiceMessage, ICommand { }\r\n\r\n\tpublic class TestEvent : ITestServiceMessage, IEvent { }\r\n\r\n\tpublic class TestRequest: ITestServiceMessage, IRequest { }\r\n\t\r\n\tpublic class TestResponse : ITestServiceMessage, IResponse { }\r\n\r\nCreate your service bus:\r\n\r\n\tIServiceBus serviceBus = ServiceBus.Configure()\r\n        .WithActiveMQEndpoints<ITestMessage>()\r\n            .Named(\"Obvs.TestService\")\r\n            .UsingQueueFor<ICommand>()\r\n            .ConnectToBroker(\"tcp://localhost:61616\")\r\n            .SerializedAsJson()\r\n            .AsClientAndServer()\r\n        .Create();\r\n\r\nSend commands:\r\n\r\n\tserviceBus.Commands.Subscribe(c => Console.WriteLine(\"Received a command!\"));\r\n\tserviceBus.SendAsync(new TestCommand())\r\n\r\nPublish events:\r\n\r\n\tserviceBus.Events.Subscribe(e => Console.WriteLine(\"Received an event!\"));\r\n\tserviceBus.PublishAsync(new TestEvent())\r\n\t\r\nRequest/response:\r\n\r\n\tserviceBus.Requests\r\n\t\t  .OfType<TestRequest>()\r\n\t\t  .Subscribe(request => serviceBus.ReplyAsync(request, new TestResponse()));\r\n\t\r\n\tserviceBus.GetResponses(new TestRequest())\r\n\t\t  .OfType<TestResponse>()\r\n\t\t  .Take(1)\r\n\t\t  .Timeout(TimeSpan.FromSeconds(1))\r\n\t\t  .Subscribe(r => Console.WriteLine(\"Received a response!\"), err => Console.WriteLine(\"Oh no!\"));\r\n\r\nDefine custom endpoints that can wrap API calls or integrations with other systems:\r\n\t\r\n\tpublic class MyCustomEndpoint : IServiceEndpointClient\r\n    \t{\r\n        \tType _serviceType = typeof(IMyCustomServiceMessage);\r\n\r\n        \tpublic IObservable<IEvent> Events\r\n        \t{\r\n            \t\tget\r\n            \t\t{\r\n                \t\t// subscribe to external MQ broker\r\n            \t\t}\r\n        \t}\r\n\r\n        \tpublic void Send(ICommand command)\r\n        \t{\r\n            \t\t// call external API\r\n        \t}\r\n\r\n        \tpublic IObservable<IResponse> GetResponses(IRequest request)\r\n        \t{\r\n            \t\t// call external API and wrap response in observable\r\n        \t}\r\n\r\n        \tpublic bool CanHandle(IMessage message)\r\n        \t{\r\n            \t\treturn _serviceType.IsInstanceOfType(message);\r\n        \t}\r\n    \t}\r\n\t\t\r\n\t...\r\n\r\n\tIServiceBus serviceBus = ServiceBus.Configure()\r\n        .WithActiveMQEndpoints<ITestMessage>()\r\n            .Named(\"Obvs.TestService\")\r\n            .UsingQueueFor<ICommand>()\r\n            .ConnectToBroker(\"tcp://localhost:61616\")\r\n            .SerializedAsJson()\r\n            .AsClientAndServer()\r\n\t\t.WithEndpoints(new MyCustomEndpoint())\r\n        .Create();\r\n\r\n## What's coming?\r\n\r\nMore transports and extensions.","google":"UA-61564782-1","note":"Don't delete this file! It's used internally to help with page regeneration."}