{"name":"Obvs","tagline":"An observable ÂµServiceBus .NET library that wraps the complexities of your particular message transport in simple Rx based interfaces. Supports ActiveMQ, NetMQ, and RabbitMQ.","body":"## Why?\r\n\r\nWriting code to connect two processes can involve a lot of boilerplate. Every time you add a new service or message type, you find yourself repeating the same steps. Obvs takes care of this for you, and allows you to start connecting your services with very little code required, so you get more done.\r\n\r\n## Features\r\n\r\n* Simple RX based interfaces for doing pub/sub\r\n* Convention based messaging over topics/queues per service\r\n* Multiplexing of multiple message types over single topics/queues\r\n* Dynamic creation of deserializers per type\r\n* Asynchronous error handling on a separate channel\r\n* Easy to extend and customise, allowing integration with external systems\r\n* Fluent code based configuration\r\n* Supports ActiveMQ, NetMQ, RabbitMQ transports\r\n* Provides serialization for XML, JSON, and ProtoBuf\r\n* Provides logging extension points, and support for NLog\r\n\r\n## Getting Started\r\n\r\nAll packages can be downloaded from [NuGet.org](https://www.nuget.org/packages?q=obvs)\r\n\r\nChoose a message transport\r\n\r\n\tinstall-package Obvs.ActiveMQ\r\n\r\nChoose a serialization format\r\n\r\n\tinstall-package Obvs.Serialization.Json\r\n\r\n## Example\r\n\r\nDefine a root message type to identify messages as belonging to your service:\r\n\r\n\tpublic interface ITestServiceMessage : IMessage { }\r\n\r\nCreate command/event/request/response message types:\r\n\r\n\tpublic class TestCommand : ITestServiceMessage, ICommand { }\r\n\r\n\tpublic class TestEvent : ITestServiceMessage, IEvent { }\r\n\r\n\tpublic class TestRequest: ITestServiceMessage, IRequest { }\r\n\t\r\n\tpublic class TestResponse : ITestServiceMessage, IResponse { }\r\n\r\nCreate your service bus:\r\n\r\n\tIServiceBus serviceBus = ServiceBus.Configure()\r\n        .WithActiveMQEndpoints<ITestMessage>()\r\n            .Named(\"Obvs.TestService\")\r\n            .UsingQueueFor<ICommand>()\r\n            .ConnectToBroker(\"tcp://localhost:61616\")\r\n            .SerializedAsJson()\r\n            .AsClientAndServer()\r\n        .Create();\r\n\r\nSend commands:\r\n\r\n\tserviceBus.Commands.Subscribe(c => Console.WriteLine(\"Received a command!\"));\r\n\tserviceBus.Send(new TestCommand())\r\n\r\nPublish events:\r\n\r\n\tserviceBus.Events.Subscribe(e => Console.WriteLine(\"Received an event!\"));\r\n\tserviceBus.Publish(new TestEvent())\r\n\t\r\nRequest/response:\r\n\r\n\tserviceBus.Requests\r\n\t\t  .OfType<TestRequest>()\r\n\t\t  .Subscribe(request => serviceBus.Reply(request, new TestResponse()));\r\n\t\r\n\tserviceBus.GetResponses(new TestRequest())\r\n\t\t  .OfType<TestResponse>()\r\n\t\t  .Take(1)\r\n\t\t  .Timeout(TimeSpan.FromSeconds(1))\r\n\t\t  .Subscribe(r => Console.WriteLine(\"Received a response!\"), err => Console.WriteLine(\"Oh no!\"));\r\n\r\nDefine custom endpoints that can wrap API calls or integrations with other systems:\r\n\t\r\n\tpublic class MyCustomEndpoint : IServiceEndpointClient\r\n    \t{\r\n        \tType _serviceType = typeof(IMyCustomServiceMessage);\r\n\r\n        \tpublic IObservable<IEvent> Events\r\n        \t{\r\n            \t\tget\r\n            \t\t{\r\n                \t\t// subscribe to external MQ broker\r\n            \t\t}\r\n        \t}\r\n\r\n        \tpublic void Send(ICommand command)\r\n        \t{\r\n            \t\t// call external API\r\n        \t}\r\n\r\n        \tpublic IObservable<IResponse> GetResponses(IRequest request)\r\n        \t{\r\n            \t\t// call external API and wrap response in observable\r\n        \t}\r\n\r\n        \tpublic bool CanHandle(IMessage message)\r\n        \t{\r\n            \t\treturn _serviceType.IsInstanceOfType(message);\r\n        \t}\r\n    \t}\r\n\t\t\r\n\t...\r\n\r\n\tIServiceBus serviceBus = ServiceBus.Configure()\r\n        .WithActiveMQEndpoints<ITestMessage>()\r\n            .Named(\"Obvs.TestService\")\r\n            .UsingQueueFor<ICommand>()\r\n            .ConnectToBroker(\"tcp://localhost:61616\")\r\n            .SerializedAsJson()\r\n            .AsClientAndServer()\r\n\t\t.WithEndpoints(new MyCustomEndpoint())\r\n        .Create();\r\n\r\n## What's coming?\r\n\r\nMore transports and a portable core library.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}