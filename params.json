{"name":"Obvs","tagline":"An observable µService bus library that wraps the complexities of your particular transport in a simple Rx based wrapper.","body":"﻿\r\n# Obvs: an observable µService bus\r\n## observable services, *obviously*\r\n\r\nFeatures:\r\n\r\n* Simple RX based interfaces for doing pub/sub\r\n* Convention based messaging over topics/queues per service\r\n* Multiplexing of multiple message types over single topics/queues\r\n* Dynamic creation of deserializers per type\r\n* Asynchronous error handling on a separate channel\r\n* Easy to extend and customise, allowing integration with external systems\r\n* Fluent code based configuration\r\n* Supports ActiveMQ and NetMQ transports\r\n* Provides serialization for XML, JSON, and ProtoBuf\r\n\r\n## Example\r\n\r\nDefine a root message type to identify messages as belonging to your service:\r\n\r\n\tpublic interface ITestServiceMessage : IMessage { }\r\n\r\nCreate command/event/request/response message types:\r\n\r\n\tpublic class TestCommand : ITestServiceMessage, ICommand { }\r\n\r\n\tpublic class TestEvent : ITestServiceMessage, IEvent { }\r\n\r\n\tpublic class TestRequest: ITestServiceMessage, IRequest { }\r\n\t\r\n\tpublic class TestResponse : ITestServiceMessage, IResponse { }\r\n\r\nCreate your service bus:\r\n\r\n\tIServiceBus serviceBus = ServiceBus.Configure()\r\n        .WithActiveMQEndpoints<ITestMessage>()\r\n            .Named(\"Obvs.TestService\")\r\n            .UsingQueueFor<ICommand>()\r\n            .ConnectToBroker(\"tcp://localhost:61616\")\r\n            .SerializedAsJson()\r\n            .AsClientAndServer()\r\n        .Create();\r\n\r\nSend commands:\r\n\r\n\tserviceBus.Commands.Subscribe(c => Console.WriteLine(\"Received a command!\"));\r\n\tserviceBus.Send(new TestCommand())\r\n\r\nPublish events:\r\n\r\n\tserviceBus.Events.Subscribe(e => Console.WriteLine(\"Received an event!\"));\r\n\tserviceBus.Publish(new TestEvent())\r\n\t\r\nRequest/response:\r\n\r\n\tserviceBus.Requests\r\n\t\t  .OfType<TestRequest>()\r\n\t\t  .Subscribe(request => serviceBus.Reply(request, new TestResponse()));\r\n\t\r\n\tserviceBus.GetResponses(new TestRequest())\r\n\t\t  .OfType<TestResponse>()\r\n\t\t  .Take(1)\r\n\t\t  .Timeout(TimeSpan.FromSeconds(1))\r\n\t\t  .Subscribe(r => Console.WriteLine(\"Received a response!\"), err => Console.WriteLine(\"Oh no!\"));\r\n\r\nDefine custom endpoints that can wrap API calls or integrations with other systems:\r\n\t\r\n\tpublic class MyCustomEndpoint : IServiceEndpointClient\r\n    \t{\r\n        \tType _serviceType = typeof(IMyCustomServiceMessage);\r\n\r\n        \tpublic IObservable<IEvent> Events\r\n        \t{\r\n            \t\tget\r\n            \t\t{\r\n                \t\t// subscribe to external MQ broker\r\n            \t\t}\r\n        \t}\r\n\r\n        \tpublic void Send(ICommand command)\r\n        \t{\r\n            \t\t// call external API\r\n        \t}\r\n\r\n        \tpublic IObservable<IResponse> GetResponses(IRequest request)\r\n        \t{\r\n            \t\t// call external API and wrap response in observable\r\n        \t}\r\n\r\n        \tpublic bool CanHandle(IMessage message)\r\n        \t{\r\n            \t\treturn _serviceType.IsInstanceOfType(message);\r\n        \t}\r\n    \t}\r\n\t\t\r\n\t...\r\n\r\n\tIServiceBus serviceBus = ServiceBus.Configure()\r\n        .WithActiveMQEndpoints<ITestMessage>()\r\n            .Named(\"Obvs.TestService\")\r\n            .UsingQueueFor<ICommand>()\r\n            .ConnectToBroker(\"tcp://localhost:61616\")\r\n            .SerializedAsJson()\r\n            .AsClientAndServer()\r\n\t\t.WithEndpoints(new MyCustomEndpoint())\r\n        .Create();\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}