<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="description" content="Obvs : An observable µService bus library that wraps the complexities of your particular transport in one simple Rx based interface.">

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">

    <title>Obvs</title>
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/inter8ection/Obvs">View on GitHub</a>

          <h1 id="project_title">Obvs</h1>
          <h2 id="project_tagline">An observable µService bus library that wraps the complexities of your particular transport in one simple Rx based interface.</h2>

            <section id="downloads">
              <a class="zip_download_link" href="https://github.com/inter8ection/Obvs/zipball/master">Download this project as a .zip file</a>
              <a class="tar_download_link" href="https://github.com/inter8ection/Obvs/tarball/master">Download this project as a tar.gz file</a>
            </section>
        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
        <h1>
<a id="obvs-an-observable-µservice-bus" class="anchor" href="#obvs-an-observable-%C2%B5service-bus" aria-hidden="true"><span class="octicon octicon-link"></span></a>Obvs: an observable µService bus</h1>

<h2>
<a id="observable-services-obviously" class="anchor" href="#observable-services-obviously" aria-hidden="true"><span class="octicon octicon-link"></span></a>observable services, <em>obviously</em>
</h2>

<h2>
<a id="why" class="anchor" href="#why" aria-hidden="true"><span class="octicon octicon-link"></span></a>Why?</h2>

<p>Writing code to connect two processes can involve a lot of boilerplate. Every time you add a new service or message type, you find yourself doing the same thing. Obvs takes care of this for you and allows you to start connecting your services with very little code required, so you get more done.</p>

<h2>
<a id="features" class="anchor" href="#features" aria-hidden="true"><span class="octicon octicon-link"></span></a>Features</h2>

<ul>
<li>Simple RX based interfaces for doing pub/sub</li>
<li>Convention based messaging over topics/queues per service</li>
<li>Multiplexing of multiple message types over single topics/queues</li>
<li>Dynamic creation of deserializers per type</li>
<li>Asynchronous error handling on a separate channel</li>
<li>Easy to extend and customise, allowing integration with external systems</li>
<li>Fluent code based configuration</li>
<li>Supports ActiveMQ and NetMQ transports</li>
<li>Provides serialization for XML, JSON, and ProtoBuf</li>
</ul>

<h2>
<a id="getting-started" class="anchor" href="#getting-started" aria-hidden="true"><span class="octicon octicon-link"></span></a>Getting Started</h2>

<p>All packages can be downloaded from <a href="https://www.nuget.org/packages?q=obvs">NuGet.org</a></p>

<p>Choose a message transport</p>

<pre><code>install-package Obvs.ActiveMQ
</code></pre>

<p>Choose a serialization format</p>

<pre><code>install-package Obvs.Serialization.Json
</code></pre>

<h2>
<a id="example" class="anchor" href="#example" aria-hidden="true"><span class="octicon octicon-link"></span></a>Example</h2>

<p>Define a root message type to identify messages as belonging to your service:</p>

<pre><code>public interface ITestServiceMessage : IMessage { }
</code></pre>

<p>Create command/event/request/response message types:</p>

<pre><code>public class TestCommand : ITestServiceMessage, ICommand { }

public class TestEvent : ITestServiceMessage, IEvent { }

public class TestRequest: ITestServiceMessage, IRequest { }

public class TestResponse : ITestServiceMessage, IResponse { }
</code></pre>

<p>Create your service bus:</p>

<pre><code>IServiceBus serviceBus = ServiceBus.Configure()
    .WithActiveMQEndpoints&lt;ITestMessage&gt;()
        .Named("Obvs.TestService")
        .UsingQueueFor&lt;ICommand&gt;()
        .ConnectToBroker("tcp://localhost:61616")
        .SerializedAsJson()
        .AsClientAndServer()
    .Create();
</code></pre>

<p>Send commands:</p>

<pre><code>serviceBus.Commands.Subscribe(c =&gt; Console.WriteLine("Received a command!"));
serviceBus.Send(new TestCommand())
</code></pre>

<p>Publish events:</p>

<pre><code>serviceBus.Events.Subscribe(e =&gt; Console.WriteLine("Received an event!"));
serviceBus.Publish(new TestEvent())
</code></pre>

<p>Request/response:</p>

<pre><code>serviceBus.Requests
      .OfType&lt;TestRequest&gt;()
      .Subscribe(request =&gt; serviceBus.Reply(request, new TestResponse()));

serviceBus.GetResponses(new TestRequest())
      .OfType&lt;TestResponse&gt;()
      .Take(1)
      .Timeout(TimeSpan.FromSeconds(1))
      .Subscribe(r =&gt; Console.WriteLine("Received a response!"), err =&gt; Console.WriteLine("Oh no!"));
</code></pre>

<p>Define custom endpoints that can wrap API calls or integrations with other systems:</p>

<pre><code>public class MyCustomEndpoint : IServiceEndpointClient
    {
        Type _serviceType = typeof(IMyCustomServiceMessage);

        public IObservable&lt;IEvent&gt; Events
        {
                get
                {
                    // subscribe to external MQ broker
                }
        }

        public void Send(ICommand command)
        {
                // call external API
        }

        public IObservable&lt;IResponse&gt; GetResponses(IRequest request)
        {
                // call external API and wrap response in observable
        }

        public bool CanHandle(IMessage message)
        {
                return _serviceType.IsInstanceOfType(message);
        }
    }

...

IServiceBus serviceBus = ServiceBus.Configure()
    .WithActiveMQEndpoints&lt;ITestMessage&gt;()
        .Named("Obvs.TestService")
        .UsingQueueFor&lt;ICommand&gt;()
        .ConnectToBroker("tcp://localhost:61616")
        .SerializedAsJson()
        .AsClientAndServer()
    .WithEndpoints(new MyCustomEndpoint())
    .Create();
</code></pre>

<h2>
<a id="whats-coming" class="anchor" href="#whats-coming" aria-hidden="true"><span class="octicon octicon-link"></span></a>What's coming?</h2>

<p>More transports and a portable core library.</p>
      </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p class="copyright">Obvs maintained by <a href="https://github.com/inter8ection">inter8ection</a></p>
        <p>Published with <a href="https://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>

    

  </body>
</html>
